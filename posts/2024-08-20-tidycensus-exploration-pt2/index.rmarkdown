---
title: "Part Two: Exploring the tidycensus R package"
description: "This post uses the tidycensus package to access the Census API and visualize data"
author:
  - name: Mickey Rafa
    url: https://mrafa3.github.io/
    #orcid: 0000-0002-5300-3075
date: 08-20-2024
categories: [R, tidyverse, tidycensus, api, javascript, purrr] # self-defined categories
#citation: 
 # url: https://mrafa3.github.io/posts/2024-07-15-wikipedia-international-mens-soccer/ 
image: facet_region.png
draft: true # setting this to `true` will prevent your post from appearing on your listing page until you're ready!
editor: 
  markdown: 
    wrap: 72
---


# Introduction

In [Part One](https://mrafa3.github.io/posts/2024-08-13-tidycensus-exploration/), I demonstrated how to fetch data and do some basic analysis of U.S. Census data. Each API call with the `tidycensus::` package can only be for one year of data, so to do longitudinal analysis requires some additional wrangling. In this post, I'll build a script that iterates through the available years, fetches the data, then combines the data into a single dataframe. Then, I'll unpack some of the trends seen in child poverty in Colorado.

## Setup


```{r libraries, include=TRUE, warning=FALSE, message=FALSE}
library(tidyverse)
library(tidycensus)
library(scales)
library(janitor)
library(gt)
library(zoo)

# census_api_key('INSERT KEY HERE')
```

```{r my.theme, include=TRUE, echo=FALSE}
my.theme <- theme(
  plot.title = ggtext::element_textbox_simple(face="bold", size=24, margin=margin(b=5)),
  plot.subtitle = ggtext::element_textbox_simple(color="#444444", size=14, margin=margin(b=10)),
  plot.caption = ggtext::element_textbox_simple(color="#444444"),
  axis.title = element_text(color="black", face="bold", size=12), 
  axis.text = element_text(color="black", size=18), 
  axis.ticks = element_blank(), 
  plot.background = element_rect(fill = 'white'),
  panel.background = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.border = element_blank(), 
  legend.title=element_blank(), 
  legend.text = element_text(color="black", size=12, hjust=0),
  legend.position = 'top',
  strip.text = element_text(color="black", size=14))
```


# Data

For this demo, I'll use the following series from the American Community Survey (ACS):

-   *B01001_003*: Estimate!!Total:!!Male:!!Under 5 years (all racial
    groups)
-   *B01001_027*: Estimate!!Total:!!Female:!!Under 5 years (all racial
    groups)
-   *B17001_004*: Estimate!!Total:!!Income in the past 12 months below
    poverty level:!!Male:!!Under 5 years
-   *B17001_018*: Estimate!!Total:!!Income in the past 12 months below
    poverty level:!!Female:!!Under 5 years

With the `tidycensus::` package, I can gather 5-year ACS data for these series from 2009 to 2022.[^1]

[^1]: According to the `tidycensus::` documentation, 5-year ACS data is available from 2009 through 2022, with the exception of 2020.

## Fetching from the `tidycensus::` API


```{r year_acs, include=TRUE}
years <- seq(2009, 2022) %>% 
  # no 2020 data from the ACS
  setdiff(2020)
```


Next, I'll define a function to fetch the ACS data for each year in the vector.


```{r fetch_poverty_data, include=TRUE}
# Define a function to fetch ACS data for a given year
fetch_acs_data <- function(year) {
  get_acs(geography = "county", 
          state = "Colorado",
          variables = c('B01001_003', 'B01001_027', 'B17001_004', 'B17001_018'),
          year = year,
          output = 'wide')
}
```


Then, I'll map the years vector to the `fetch_acs_data()` function that I created.


```{r acs_data_list, include=TRUE}
# Use map() to apply fetch_acs_data to each year
acs_data_list <- map(years, fetch_acs_data)
```


## Data wrangling

Then, I'll create a `year` field for each dataframe in the list, so that I can create one, multi-year dataframe.


```{r map2_acs_data_list, include=TRUE}
acs_data_list <- map2(acs_data_list, years, ~ mutate(.x, year = .y))
```


Now, I'll bind all of the ACS years together into a single dataframe for analysis.


```{r combined_acs_data, include=TRUE}
combined_acs_data <- bind_rows(acs_data_list)
```

```{r extract_acs_data, include=FALSE}
# If I wanted to write each year to the global environment, here's how
# extract_acs_data <- function(data_list, prefix = "acs_") {
#   walk2(
#     names(data_list),
#     data_list,
#     ~ assign(paste0(prefix, .x), .y, envir = .GlobalEnv)
#   )
# }

# extract_acs_data(acs_data_list)
```


Then, I'll follow the same data wrangling steps from Part One:

*  Updating the column names to be more user-friendly


```{r update_colnames, include=TRUE}
name_cols <- c('geoid', 'county_state', 
               'u5_male_estimate', 'u5_male_moe', 
               'u5_female_estimate', 'u5_female_moe',
               'u5_male_pov_estimate', 'u5_male_pov_moe',
               'u5_female_pov_estimate', 'u5_female_pov_moe',
               'year')

colnames(combined_acs_data) <- name_cols
```


*  Dropping the margin of error fields


```{r drop_cols, include=TRUE}
combined_acs_data <- combined_acs_data %>% 
  select(-contains("moe"))
```


*  Creating some fields to combine gender-based poverty estimates and calculate a percent of the child population measure


```{r df_mutate, include=TRUE, results='hide'}
combined_acs_data <- combined_acs_data %>% 
  mutate(u5_pop_total = u5_male_estimate + u5_female_estimate,
         u5_pov_total = u5_male_pov_estimate + u5_female_pov_estimate,
         u5_perc_in_poverty = u5_pov_total / u5_pop_total)
```


*  Creating a `county` field that cleans the `county_state` field to only include the county name


```{r mutate_county_name, include=TRUE}
combined_acs_data <- combined_acs_data %>% 
  mutate(county = str_remove(county_state, " County.*")) %>% 
  select(county, everything())
```


*  Reading in a table that maps Colorado's counties to a region of the state


```{r read_colorado_regions, include=TRUE}
colorado_regions <- read_csv('.//data/colorado_regions.csv', show_col_types = FALSE) %>%
  mutate(region = as.factor(region))
```

*  (Finally) creating the `combined_acs_data` dataframe for longitudinal analysis


```{r join_colorado_regions, include=TRUE}
combined_acs_data <- combined_acs_data %>% 
  left_join(x=.,
            y=colorado_regions,
            by='county')
```


# Analysis 


```{r lineplot_gg, include=FALSE}
combined_acs_data %>% 
  ggplot(.,
         aes(x=year,
             y=u5_perc_in_poverty,
             group=county)) + 
  geom_line()
```


For the graphics, I'll use Observable Plot to build some interactive graphics (this can be done with R, but I want to experiment more with what Javascript can do).

To use Observable Plot in Quarto, you need to first have your data object defined in an Observable JS object, which can be achieved by:

*  Reading in the object directly as an Observable JS object (such as with the `FileAttachment()` function), or
*  Converting your R or Python object using the `ojs_define()` function in an R or Python code chunk

Note that, if you choose the latter (which I'll do here), this object only operates when your site or knitr document is rendered (meaning, it won't execute as a code chunk like you can with R, Python, or SQL in Quarto).


```{r ojs_define_chunk, include=TRUE}
ojs_define(ojsd = combined_acs_data)
```


Then, I'll create a line plot of child poverty by county over time, faceting by region.


```{ojs plot_ojs_line, include=TRUE}
Plot.plot({
  <!-- using options from here to learn: https://observablehq.com/plot/features/facets -->
  title: "Child poverty (%) in Colorado by county",
  caption: "Source: American Community Survey",
  width: 1200,
  heigh: 600,
  x: {nice: true,
      label: "Year",
      ticks: 5,
      tickFormat: d => d.toString(),
      labelFontSize: 50,
      tickSize: 5,
      tickFontSize: 12
  },
  color: {type: "categorical"},
  y: {
    grid: true,
    label: "Child poverty rate (%)",
    domain: [0, 100]
    <!-- labelFontSize: 50, -->
    <!-- tickFontSize: 50 -->
  },
  fx: {
    label: "Region"
    <!-- these are not working -->
    <!-- tickFontSize: 32, -->
    <!-- labelFontSize: 32 -->
  },
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(transpose(ojsd), {
    x: "year", 
    fx: "region",
    y: d => d.u5_perc_in_poverty * 100, 
    z: "county", 
    stroke: "region",
    tip: true})
  ]
})
```


Some comments on the above:

*  There are discussions online that indicate that not all Javascript styling works in Quarto, and this supports that (some font size elements don't seem to work, faceting options, etc.). I'd like to test that in Observable directly, but for now, I'll just note that this is not my *favorite* styling.
*  Aside from the Front Range, which is showing some smooth patterns, there's pretty significant volatility in these child poverty estimates. I'll rebuild this chart, using a 3-year moving average with the `zoo::rollmean()` function.


```{r combined_acs_data2, include=TRUE}
combined_acs_data2 <- combined_acs_data %>% 
  group_by(county) %>%
  mutate(u5_perc_poverty_3_yr_moving_avg = rollmean(u5_perc_in_poverty, k=3, fill=NA, align='right'))
```

```{r define_ojsd2, include=TRUE, echo=FALSE}
ojs_define(ojsd2 = combined_acs_data2)
```

```{ojs plot_ojs_line2, include=TRUE, echo=FALSE}
Plot.plot({
  <!-- using options from here to learn: https://observablehq.com/plot/features/facets -->
  title: "Child poverty (%) in Colorado by county",
  caption: "Source: American Community Survey. Generated 3-year moving average to smooth results.",
  width: 1200,
  x: {nice: true,
      tickFormat: d => d.toString()
      },
  <!-- y: {inset: 5}, -->
  color: {type: "categorical"},
  y: {
    grid: true,
    label: "Child poverty rate (%)",
    domain: [0, 100]
  },
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(transpose(ojsd2), {
    x: "year", 
    fx: "region",
    y: d => d.u5_perc_poverty_3_yr_moving_avg * 100, 
    z: "county", 
    stroke: "region",
    tip: true})
  ]
})
```

```{r define_ojsd3, include=FALSE, echo=FALSE}
ojs_define(ojsd3 = combined_acs_data %>% filter(region == 'Front Range'))
```

```{ojs plot_ojs_line3, include=FALSE}
Plot.plot({
  <!-- using options from here to learn: https://observablehq.com/plot/features/facets -->
  title: "Child poverty (%) in Colorado by county: Front Range",
  caption: "Source: American Community Survey",
  width: 1200,
  heigh: 600,
  x: {nice: true,
      label: "Year",
      ticks: 5,
      tickFormat: d => d.toString(),
      labelFontSize: 40,
      tickSize: 5,
      tickFontSize: 12
  },
  color: {type: "categorical"},
  y: {
    grid: true,
    label: "Child poverty rate (%)",
    domain: [0, 40]
    <!-- labelFontSize: 50, -->
    <!-- tickFontSize: 50 -->
  },
  marks: [
    Plot.tip(
      [`Starting in x, `],
      {x: 2014, y: 30, dy: -3, anchor: "bottom"}),
    Plot.text(ojsd3, {
        x: "year",
        y:  d => d.u5_perc_in_poverty * 100, 
        z: "county",
        text: "county",
        textAnchor: "start",
        dx: 3
      }),
    Plot.ruleY([0]),
    Plot.lineY(transpose(ojsd3), {
    x: "year", 
    y: d => d.u5_perc_in_poverty * 100, 
    z: "county", 
    stroke: "county",
    tip: true})
  ]
})
```

```{r combined_acs_data3, include=FALSE}
# If your goal is to communicate change over time, the variability year-over-year might not be necessary. That's where a slope chart comes in! With that chart time, you're summarizing the information by showing only your first and last values, and the linear change between those years.

# combined_acs_data3 <- combined_acs_data %>% 
#   group_by(county, region) %>% 
#   filter(year %in% c('2009', '2022'))
```

```{r facet_slope_chart, include=FALSE}
# combined_acs_data3 %>% 
#   ggplot(.,
#          aes(x=year,
#              y=u5_perc_in_poverty,
#              group=county)) + 
#   geom_line() + 
#   facet_wrap(~region) + 
#   my.theme
```


# Conclusion

In this `tidycensus::` post, I demonstrated:

-   How to fetch data across multiple years from the U.S. Census Bureau and wrangle the data for longitudinal analysis
-   How to move between R or Python objects and Observable JS objects in Quarto 
-   How to make some simple interactive graphics with Observable Plot

More to come on poverty analysis in future posts!
