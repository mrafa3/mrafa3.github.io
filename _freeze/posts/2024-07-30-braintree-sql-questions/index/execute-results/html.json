{
  "hash": "2529d1aed1c2181e7529593a47175919",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"BrainTree SQL challenge\"\ndescription: \"This post works through the SQL challenges used by PayPal\"\nauthor:\n  - name: Mickey Rafa\n    url: https://mrafa3.github.io/\n    #orcid: 0000-0002-5300-3075\ndate: 07-30-2024\ncategories: [SQL, Quarto] # self-defined categories\n#citation: \n # url: https://mrafa3.github.io/posts/2024-07-15-wikipedia-international-mens-soccer/ \nimage: query.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# Introduction\n\nThe BrainTree SQL coding challenge is known as a great challenge for\ndata analysts looking to test their skills. In this project, I am\nputting my skills to the test, using Quarto and the `DBI::` and\n`RSQLite::` packages to run SQL queries on an in-memory database.\n\n## Setup and data preparation\n\n**Required packages**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(DBI)\nlibrary(RSQLite)\n```\n:::\n\n\n**About the dataset**:\n\nHere is some text from the BrainTree challenge site:\n\n> This is an opportunity for you to show us your grasp of SQL which\n> plays a key role in the day-to-day job that you're applying for. All\n> members of the Analytics Data team have taken this challenge and\n> participated in its creation. If you feel that there are any questions\n> that are either not fair or not clear, please do let us know; this is\n> VERY important to us! A few important things to note before you get\n> started:\n\n> -   All work should be done in SQL. Any variant is fine (e.g. MS SQL,\n>     Postgres, MySQL, etc.). If you normally use R, SAS, or other\n>     similar tools with SQL it's important that you show that you can\n>     work in SQL by itself to produce the correct answers to this\n>     challenge.\n> -   If you are confused by a specific question, you can request\n>     clarification by replying to the message that this challenge was\n>     attached to. This is NOT intended for you to obtain technical help\n>     with solving the problems on this challenge or asking for hints;\n>     it should only be used for question clarification. This challenge\n>     is due back within 1 week (7 calendar days) of being sent to you.\n> -   If you cannot answer a question, please do your best, show your\n>     work, leave comments, and let us know your general thoughts.\n> -   We are interested in BOTH your answers and the work/code that you\n>     write to get them. Please leave plenty of comments for us to read\n>     when we review your work.\n> -   There are some blank/null values in this set. That's how we found\n>     it and it reflects the nature of imperfect data. Please work with\n>     this and provide explanations of any issues or workarounds\n>     required to arrive at your answers.\n> -   There are no intentional gotchas, trick questions, or traps; the\n>     challenge is intended to demonstrate some of the typical\n>     day-to-day SQL skills that the job requires.\n> -   Some of these questions may seem nonsensical and you may find\n>     yourself asking, \"why would anyone want to know that?!\" They are\n>     intended purely as a measure of your SQL skills and not as actual\n>     questions that we would expect to ask of this type of data set.\n>     Please take them with a grain of salt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountries <- read_csv('.//data/countries.csv')\ncontinent_map <- read_csv('.//data/continent_map.csv')\ncontinents <- read_csv('.//data/continents.csv')\nper_capita <- read_csv('.//data/per_capita.csv')\n```\n:::\n\n\n## Setting up SQL to execute\n\nThe `DBI::` package allows you to create an in-memory database to query\nagainst. The [DBI project site](https://r-dbi.org/) is a great place to\nlearn more about it. I'll start by doing some initial setup and\nestablishing the connection between the R dataframe and the SQL table\nname that I'll query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(SQLite(), \":memory:\")\nDBI::dbWriteTable(conn = con, name = \"continent_map\", value = continent_map)\nDBI::dbWriteTable(conn = con, name = \"per_capita\", value = per_capita)\nDBI::dbWriteTable(conn = con, name = \"continents\", value = continents)\nDBI::dbWriteTable(conn = con, name = \"countries\", value = countries)\n```\n:::\n\n\n# Questions\n\n1.  Data Integrity Checking & Cleanup\n\nAlphabetically list all of the country codes in the continent_map table\nthat appear more than once. Display any values where country_code is\nnull as country_code = \"FOO\" and make this row appear first in the list,\neven though it should alphabetically sort to the middle. Provide the\nresults of this query as your answer.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n      CASE WHEN country_code IS NULL THEN \"FOO\" ELSE country_code END as country_code,\n      count(*) as cnt_country\nfrom continent_map\ngroup by country_code\nhaving cnt_country > 1\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 9 records\n\n|country_code | cnt_country|\n|:------------|-----------:|\n|FOO          |           4|\n|ARM          |           3|\n|AZE          |           2|\n|CYP          |           2|\n|GEO          |           2|\n|KAZ          |           2|\n|RUS          |           2|\n|TUR          |           2|\n|UMI          |           2|\n\n</div>\n:::\n\n\nFor all countries that have multiple rows in the continent_map table,\ndelete all multiple records leaving only the 1 record per country. The\nrecord that you keep should be the first one when sorted by the\ncontinent_code alphabetically ascending. Provide the query/ies and\nexplanation of step(s) that you follow to delete these records.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith continent_map_update as (\nselect *,\n        ROW_NUMBER() OVER(\n            partition by country_code\n            order by country_code asc) as seq\nfrom continent_map)\nselect *\nfrom continent_map_update\nwhere seq = 1\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: Displaying records 1 - 10\n\n|country_code |continent_code | seq|\n|:------------|:--------------|---:|\n|NA           |OC             |   1|\n|ABW          |NA             |   1|\n|AFG          |AS             |   1|\n|AGO          |AF             |   1|\n|AIA          |NA             |   1|\n|ALA          |EU             |   1|\n|ALB          |EU             |   1|\n|AND          |EU             |   1|\n|ANT          |NA             |   1|\n|ARE          |AS             |   1|\n\n</div>\n:::\n\n\n2.  List the countries ranked 10-12 in each continent by the percent of\n    year-over-year growth descending from 2011 to 2012.\n\nThe percent of growth should be calculated as: ((2012 gdp - 2011 gdp) /\n2011 gdp)\n\nThe list should include the columns:\n\n-   rank\n-   continent_name\n-   country_code\n-   country_name\n-   growth_percent\n\nFor this question, there are two elements of data cleaning:\n\n-   To list the **countries** and their ranking, I filtered out the many\n    country codes that actually represented regions or country income\n    groupings.\n-   The `continent_name` is NA for North America, and I wanted to\n    generate the results in a cleaner way.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith df as (\nselect \n        p.*,\n        countries.country_name,\n        CASE WHEN p.country_code IN ('EAP', 'EAS', 'LIC', 'ARB', 'NOC', 'UMC', 'MEA', 'PSS', 'MNA', 'MIC', 'LMY', 'HPC', 'NAC', 'LDC', 'LMC', 'SSF', 'SSA', 'CSS', 'WLD', 'ECA', 'HIC', 'OEC', 'OED', 'SST', 'LCN', 'SAS', 'LAC', 'OSS', 'ECS', 'EUU', 'EMU') THEN 'Region' ELSE 'Country' END as country_region,\n        CASE WHEN c.continent_name IS NULL THEN 'North America' ELSE c.continent_name END as continent_name,\n        LAG(p.gdp_per_capita, 1, NULL) OVER(\n            partition by p.country_code\n            order by year) as t0_gdp_pc\nfrom per_capita p\nleft join continent_map m\non p.country_code = m.country_code\nleft join continents c\non m.continent_code = c.continent_code\nleft join countries\non p.country_code = countries.country_code\nwhere country_region = 'Country'\n),\ngrowth as (\nselect \n        *,\n        round(((gdp_per_capita - t0_gdp_pc)/ t0_gdp_pc) * 100, 2) as growth_percent\nfrom df\n),\nrank_2012 as (\nselect \n        *,\n        RANK() OVER(\n            partition by continent_name\n            order by growth_percent desc) as rank\nfrom growth\nwhere year = 2012\nand growth_percent IS NOT NULL\n)\nselect\n          rank,\n          continent_name,\n          country_code,\n          country_name,\n          concat(growth_percent,'%') as growth_percent\nfrom rank_2012\norder by growth_percent desc\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: Displaying records 1 - 10\n\n| rank|continent_name |country_code |country_name        |growth_percent |\n|----:|:--------------|:------------|:-------------------|:--------------|\n|    8|Africa         |LBR          |Liberia             |9.77%          |\n|   12|Asia           |PHL          |Philippines         |9.73%          |\n|   13|Asia           |KWT          |Kuwait              |9.68%          |\n|    9|Africa         |EGY          |Egypt, Arab Rep.    |9.53%          |\n|   14|Asia           |GEO          |Georgia             |8.92%          |\n|   10|Africa         |RWA          |Rwanda              |8.73%          |\n|    4|Oceania        |AUS          |Australia           |8.63%          |\n|    2|North America  |KNA          |St. Kitts and Nevis |8.45%          |\n|    3|North America  |CRI          |Costa Rica          |8.38%          |\n|    6|South America  |COL          |Colombia            |8.38%          |\n\n</div>\n:::\n\n\n3.  For the year 2012, create a 3 column, 1 row report showing the\n    percent share of gdp_per_capita for the following regions:\n\n<!-- -->\n\n(i) Asia, (ii) Europe, (iii) the Rest of the World. Your result should\n    look something like\n\nAsia Europe Rest of World 25.0% 25.0% 50.0%\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith df as (\nselect \n        p.*,\n        countries.country_name,\n        CASE WHEN p.country_code IN ('EAP', 'EAS', 'LIC', 'ARB', 'NOC', 'UMC', 'MEA', 'PSS', 'MNA', 'MIC', 'LMY', 'HPC', 'NAC', 'LDC', 'LMC', 'SSF', 'SSA', 'CSS', 'WLD', 'ECA', 'HIC', 'OEC', 'OED', 'SST', 'LCN', 'SAS', 'LAC', 'OSS', 'ECS', 'EUU', 'EMU') THEN 'Region' ELSE 'Country' END as country_region,\n        CASE WHEN c.continent_name IS NULL THEN 'North America' ELSE c.continent_name END as continent_name,\n        LAG(p.gdp_per_capita, 1, NULL) OVER(\n            partition by p.country_code\n            order by year) as t0_gdp_pc\nfrom per_capita p\nleft join continent_map m\non p.country_code = m.country_code\nleft join continents c\non m.continent_code = c.continent_code\nleft join countries\non p.country_code = countries.country_code\nwhere country_region = 'Country'\n),\nsum_by_continent as (\nselect \n        continent_name,\n        sum(gdp_per_capita) as sum_gdp_per_capita\nfrom df\nwhere year = 2012\ngroup by continent_name\n),\nsum_total as (\nselect\n        sum(gdp_per_capita) as ttl_gdp_per_capita\nfrom df\nwhere year = 2012\n),\npercent_tbl as (\nselect \n          sum_by_continent.*,\n          sum_total.ttl_gdp_per_capita,\n          round((sum_gdp_per_capita / ttl_gdp_per_capita) * 100, 1)  as percent\nfrom sum_by_continent, sum_total\n),\ntbl_sums as (\nselect\n        CASE WHEN continent_name = 'Asia' THEN 'Asia' \n        WHEN continent_name = 'Europe' THEN 'Europe' \n        ELSE 'Rest of World' END as continent_groups,\n        sum(percent) as percent\nfrom percent_tbl\ngroup by continent_groups\n)\nselect\n        MAX(CASE WHEN continent_groups = 'Asia' THEN concat(percent, '%') END) AS Asia,\n        MAX(CASE WHEN continent_groups = 'Europe' THEN concat(percent, '%') END) AS Europe,\n        MAX(CASE WHEN continent_groups = 'Rest of World' THEN concat(percent, '%') END) AS Rest_of_World\nFROM tbl_sums\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n|Asia  |Europe |Rest_of_World |\n|:-----|:------|:-------------|\n|27.6% |43.8%  |28.6%         |\n\n</div>\n:::\n\n\n4a. What is the count of countries and sum of their related\ngdp_per_capita values for the year 2007 where the string 'an' (case\ninsensitive) appears anywhere in the country name?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n        count(*) as nbr_countries,\n        sum(per_capita.gdp_per_capita) as sum_gdp_per_capita\nfrom per_capita\nleft join countries\non per_capita.country_code = countries.country_code\nwhere countries.country_name like '%an%'\nand year = 2007\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| nbr_countries| sum_gdp_per_capita|\n|-------------:|------------------:|\n|            68|            1022936|\n\n</div>\n:::\n\n\n4b. Repeat question 4a, but this time make the query case sensitive.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect\n        count(*) as nbr_countries,\n        sum(per_capita.gdp_per_capita) as sum_gdp_per_capita\nfrom per_capita\nleft join countries\non per_capita.country_code = countries.country_code\nwhere countries.country_name glob '*an*'\nand year = 2007\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| nbr_countries| sum_gdp_per_capita|\n|-------------:|------------------:|\n|            66|           979600.7|\n\n</div>\n:::\n\n\n5.  Find the sum of gpd_per_capita by year and the count of countries\n    for each year that have non-null gdp_per_capita where (i) the year\n    is before 2012 and (ii) the country has a null gdp_per_capita\n    in 2012. Your result should have the columns:\n\nyear country_count total\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nselect \n    year,\n    count(country_code) as country_count,\n    sum(gdp_per_capita) as total\nfrom per_capita\nwhere 1 = 1\nand gdp_per_capita IS NOT NULL\nand country_code IN \n    (select country_code\n    from per_capita\n    where year = 2012\n    and gdp_per_capita IS NULL)\ngroup by year\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 8 records\n\n|year | country_count|    total|\n|:----|-------------:|--------:|\n|2004 |            15| 491203.2|\n|2005 |            15| 510735.0|\n|2006 |            14| 553689.6|\n|2007 |            14| 654508.8|\n|2008 |            10| 574016.2|\n|2009 |             9| 473103.3|\n|2010 |             4| 179750.8|\n|2011 |             4| 199152.7|\n\n</div>\n:::\n\n\n6.  All in a single query, execute all of the steps below and provide\n    the results as your final answer:\n\n<!-- -->\n\na.  create a single list of all per_capita records for year 2009 that\n    includes columns:\n\ncontinent_name country_code country_name gdp_per_capita\n\nb.  order this list by:\n\ncontinent_name ascending characters 2 through 4 (inclusive) of the\ncountry_name descending\n\nc.  create a running total of gdp_per_capita by continent_name\n\nd.  return only the first record from the ordered list for which each\n    continent's running total of gdp_per_capita meets or exceeds\n    \\$70,000.00 with the following columns:\n\ncontinent_name country_code country_name gdp_per_capita running_total\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith df as (\nselect\n        CASE WHEN continents.continent_name IS NULL THEN 'North America'\n            ELSE continents.continent_name END as continent_name,\n        per_capita.country_code,\n        countries.country_name,\n        per_capita.gdp_per_capita,\n        ROW_NUMBER() OVER(\n        partition by continent_name\n            order by substr(country_name, 2, 3) desc) as row_number,\n        SUM(gdp_per_capita) OVER(\n            partition by continent_name\n            order by substr(country_name, 2, 3) desc) as running_total\nfrom per_capita\nleft join countries\non per_capita.country_code = countries.country_code\nleft join continent_map\non per_capita.country_code = continent_map.country_code\nleft join continents\non continent_map.continent_code = continents.continent_code\nwhere year = 2009\norder by continent_name asc\n),\ncriteria as (\nselect\n        continent_name,\n        country_code,\n        country_name,\n        gdp_per_capita,\n        running_total,\n        row_number\nfrom df\nwhere running_total >= 70000.00\n),\nfinal as (\nselect\n        continent_name,\n        country_code,\n        country_name,\n        gdp_per_capita,\n        running_total,\n        ROW_NUMBER() OVER(\n            partition by continent_name) as row_number\nfrom criteria\n)\nselect *\nfrom final\nwhere row_number = 1\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 6 records\n\n|continent_name |country_code |country_name                            | gdp_per_capita| running_total| row_number|\n|:--------------|:------------|:---------------------------------------|--------------:|-------------:|----------:|\n|Africa         |LBY          |Libya                                   |      10455.575|      70227.16|          1|\n|Asia           |KWT          |Kuwait                                  |      37160.543|      73591.81|          1|\n|Europe         |CHE          |Switzerland                             |      65790.067|     119051.78|          1|\n|North America  |ECA          |Europe & Central Asia (developing only) |       5495.417|      97451.38|          1|\n|Oceania        |NZL          |New Zealand                             |      27474.333|      84623.92|          1|\n|South America  |ECU          |Ecuador                                 |       4236.778|      72315.82|          1|\n\n</div>\n:::\n\n\n7.  Find the country with the highest average gdp_per_capita for each\n    continent for all years. Now compare your list to the following data\n    set. Please describe any and all mistakes that you can find with the\n    data set below. Include any code that you use to help detect these\n    mistakes.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith df as (\nselect\n        per_capita.country_code,\n        countries.country_name,\n        per_capita.year,\n        CASE WHEN continent_map.continent_code IS NULL THEN 'NA' \n            ELSE continent_map.continent_code END as continent_code,\n        CASE WHEN continents.continent_name IS NULL THEN 'North America' \n            ELSE continents.continent_name END as continent_name,\n        CASE WHEN per_capita.country_code IN ('EAP', 'EAS', 'LIC', 'ARB', 'NOC', 'UMC', 'MEA', 'PSS', 'MNA', 'MIC', 'LMY', 'HPC', 'NAC', 'LDC', 'LMC', 'SSF', 'SSA', 'CSS', 'WLD', 'ECA', 'HIC', 'OEC', 'OED', 'SST', 'LCN', 'SAS', 'LAC', 'OSS', 'ECS', 'EUU', 'EMU') THEN 'Region' ELSE 'Country' END as country_region,\n        per_capita.gdp_per_capita\nfrom per_capita\nleft join continent_map\non per_capita.country_code = continent_map.country_code\nleft join countries\non per_capita.country_code = countries.country_code\nleft join continents\non continent_map.continent_code = continents.continent_code\n),\navg_gdp_per_capita as (\nselect\n        continent_name,\n        country_name,\n        country_code,\n        round(AVG(gdp_per_capita), 2) as avg_gdp_per_capita\nfrom df\nwhere country_region = 'Country'\ngroup by continent_name, country_name, country_code\n),\nrank as (\nselect \n        *,\n        RANK() OVER(\n            partition by continent_name\n            order by avg_gdp_per_capita desc) as rank_gdp_per_capita\nfrom avg_gdp_per_capita\n)\nselect *\nfrom rank\nwhere rank_gdp_per_capita = 1\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 6 records\n\n|continent_name |country_name      |country_code | avg_gdp_per_capita| rank_gdp_per_capita|\n|:--------------|:-----------------|:------------|------------------:|-------------------:|\n|Africa         |Equatorial Guinea |GNQ          |           17955.72|                   1|\n|Asia           |Qatar             |QAT          |           70567.96|                   1|\n|Europe         |Monaco            |MCO          |          151421.89|                   1|\n|North America  |Bermuda           |BMU          |           84634.83|                   1|\n|Oceania        |Australia         |AUS          |           46147.45|                   1|\n|South America  |Chile             |CHL          |           10781.71|                   1|\n\n</div>\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}